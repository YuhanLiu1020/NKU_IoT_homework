# Lab2:配置Web服务器，分析HTTP交互过程

**实验项目**：搭建Web服务器、制作简单Web页面、分析HTTP交互过程  
**专业**：物联网工程  
**学号**：2213244  
**姓名**：刘玉菡  

---

## 一、实验目的
1. 熟悉Web服务器的搭建流程。
2. 掌握使用HTML、CSS构建简单Web页面的方法。
3. 了解并分析HTTP请求与响应的交互过程。
4. 使用Wireshark捕获并分析网络数据包，学习HTTP协议的工作机制。

---

## 二、实验环境
- **操作系统**：Windows11
- **Web服务器**：IIS（Internet Information Services）
- **开发工具**：Visual Studio 2022 (VS2022)
- **页面设计语言**：HTML
- **网络抓包工具**：Wireshark

---

## 三、实验步骤

### 1. 搭建Web服务器
- **启用IIS**：在Windows的“控制面板 > 程序 > 启用或关闭Windows功能”中启用 **Internet Information Services (IIS)**。

- **配置网站**：
  - 在IIS管理器中，选择“Default Web Site”并设定端口为8081（避免与系统占用的端口冲突）。
  
  - 将HTML页面及相关资源（LOGO图片、音频文件等）放入IIS根目录（`C:\inetpub\wwwroot`）。
  
    ![05c1a145b3112b6aaf120a5136880df](.\05c1a145b3112b6aaf120a5136880df.png)

### 2. 制作简单的Web页面
- **页面内容**：
  - HTML文件包含个人信息（专业、学号、姓名）、个人LOGO以及一段自我介绍音频。
  - 页面代码不在这里赘述，详情请看该报告同目录下index.html文件。
  - 打开浏览器，输入`http://127.0.0.1:8081`得到如下界面。![index_page](.\index_page.png)
- **页面资源**：
  - **logo.jpg**：个人LOGO图片，放在服务器根目录。
  - **intro.mp3**：自我介绍的音频文件，放在服务器根目录。
  - **favicon.ico**：网页图标文件，用于显示在浏览器标签栏。

### 3. 使用Wireshark捕获交互过程
- 打开Wireshark并选择“Adapter for loopback traffic capture”接口。
- 设置过滤器 `(ip.dst == 127.0.0.1 or ip.src == 127.0.0.1) and (tcp.srcport == 8081 or tcp.dstport == 8081)`，只显示8081端口的HTTP流量。
- 访问页面后，Wireshark开始捕获浏览器与Web服务器之间的HTTP交互。运行一段时间得到如下结果。![5a7c1b068564e6bc03799bf04553049](.\5a7c1b068564e6bc03799bf04553049.png)

---

## 四、实验结果

### 1. TCP三次握手建立连接

TCP 三次握手的过程解决以下三个问题

1. 要是每一方都能确知对方的存在
2. 要允许双方协商一些参数(如窗口最大值，是否使用窗口扩大选项以及时间戳选项等)
3. 能够对运输实体资源(如缓冲大小、连接表中的项目等)进行分配

下图展示了连接建立的三次握手过程：![175f0ad4bd6242af6b5d254b051270c](E:\computer_network\Lab2\175f0ad4bd6242af6b5d254b051270c.png)



在wireshark中可以看到三次握手的过程：

![3363d82db10d57439902ccc73c792f6](E:\computer_network\Lab2\3363d82db10d57439902ccc73c792f6.png)



- **初始状态**：客户端处于`closed`(关闭)状态，服务器处于`listen`(监听)状态 （有地方说也处于关闭状态）

- **第一次握手**：建立连接时，客户端发送`SYN`包`[syn=x ] `到服务器，并进入`SYN_Send`状态 ，表示请求与服务器建立连接，等待服务器确认。报文` SYN = 1` 同步序列号和初始化序列号`seq = x`发送给服务端 。这个步骤的作用是让客户端告诉服务器它准备好通信，并发送自己的初始序列号。

  ![ec02a8b1f05d7f05a31c4ef6e62f2b7](E:\computer_network\Lab2\ec02a8b1f05d7f05a31c4ef6e62f2b7.png)

  在**第1741行**的抓包数据中，可以看到客户端向服务器发送的`SYN`包，用于发起连接请求。主要参数如下：

  - **源端口**：55805（客户端发起）
  - **目标端口**：8081（服务器监听端口）
  - **标志位**：`SYN` 设置为 `1`
  - **序列号**：`Sequence Number = 0`
  - **确认号**：`Acknowledgment Number = 0`（此时不需要确认，因为是初始请求）

  

- **第二次握手**：服务端受到`SYN`请求报文之后，如果同意连接，会以自己的同步序列号`SYN = 1`、初始化序列号`seq = y`和确认序列号（期望下次收到的数据包）`ack = x+ 1`以及确认号`ACK = 1`报文作为应答，服务器为`SYN_Receive`状态。这一步确保服务器接收到客户端的请求，同时将自己的连接意图传达给客户端。

  ![4d58adb0a7e2480f939e09024d21244](E:\computer_network\Lab2\4d58adb0a7e2480f939e09024d21244.png)

  在**第1742行**的抓包数据中，服务器响应客户端的连接请求，发送`SYN, ACK`包，表示接受连接请求并回复确认。主要参数如下：

  - **源端口**：8081（服务器响应）
  - **目标端口**：55805（客户端端口）
  - **标志位**：`SYN` 和 `ACK` 都设置为 `1`
  - **序列号**：`Sequence Number = 0`
  - **确认号**：`Acknowledgment Number = 1`（确认客户端的序列号 `0 + 1`）

  

- **第三次握手**：客户端接收到服务端的`SYN + ACK`之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号`ack = y + 1`和数据包的序列号`seq = x + 1`以及确认号`ACK = 1`确认包作为应答，客户端转为`established`状态。服务器收到客户端的应答报文后，也进入 `ESTABLISHED` 状态，正式建立连接。三次握手完成后，双方可以进行数据传输。

  ![ededae24c580ceab503f4ec1290c0a7](E:\computer_network\Lab2\ededae24c580ceab503f4ec1290c0a7.png)

  在**第1743行**的抓包数据中，客户端发送`ACK`包以确认连接，完成三次握手过程。主要参数如下：

  - **源端口**：55805（客户端）
  - **目标端口**：8081（服务器）
  - **标志位**：`ACK` 设置为 `1`
  - **序列号**：`Sequence Number = 1`（客户端的下一个序列号）
  - **确认号**：`Acknowledgment Number = 1`（确认服务器的序列号 `0 + 1`）

### 2. HTTP请求与响应

在连接建立后，客户端向服务器发送了4个HTTP请求，包括HTML页面、图片、音频文件和favicon图标。典型的 HTTP 请求由请求行（如 GET）、请求头和可选的消息体组成，服务器接收到请求后会返回 HTTP 响应，包括状态行（如 200 OK）、响应头和消息体。每种请求类型（如 GET、POST）对应不同的操作，GET 请求用于获取资源，POST 请求用于提交数据。在本实验中，主要观察了 GET 请求的发送和服务器的响应过程。![d87771d7de37ee15342ba44beddfa5f](E:\computer_network\Lab2\d87771d7de37ee15342ba44beddfa5f.png)

以下是每个请求的详细分析：

- **HTML页面请求**：
  - **请求**：在 **第1747行**，客户端发起 `GET / HTTP/1.1` 请求以获取HTML页面内容。
  - **响应**：在 **第1751行**，服务器返回 `HTTP/1.1 200 OK`，Content-Type 为 `text/html`，表明页面内容正常加载。
- **LOGO图片请求**：
  - **请求**：在 **第1761行**，客户端请求 `GET /logo.jpg`。
  - **响应**：在 **第1767行**，服务器返回 `HTTP/1.1 200 OK`，Content-Type 为 `image/jpeg`，表示图片资源加载成功。
- **音频文件请求**：
  - **请求**：在 **第1785行**，客户端请求 `GET /intro.mp3`。
  - **响应**：在 **第1787行**，服务器返回 `HTTP/1.1 200 OK`，Content-Type 为 `audio/mpeg`，说明音频文件成功加载。
- **favicon.ico请求**：
  - **请求**：在 **第1754行**，客户端请求 `GET /favicon.ico`。
  - **响应**：在 **第1756行**，服务器返回 `HTTP/1.1 200 OK`，Content-Type 为 `image/x-icon`，表明favicon图标加载成功，用于显示在浏览器标签栏上。

#### (一）HTTP报文结构

HTTP有两类报文:

- 请求报文—— 从客户向服务器发送请求报文
- 响应报文—— 从服务器到客户的回答

HTTP请求报文和响应报文都是由三个部分组成的：

- **开始行**，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行(Request-Line)，而在响应报文中的开始行叫做状态行(Status-Line)。在开始行的三个字段之间都以空格分隔开，最后的“CR”和“LF”分别代表“回车”和“换行”。
- **首部行**，用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。
- **实体主体**(entity body)，在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。



![4ae3086df4f10891ec632eb7f1288f4](E:\computer_network\Lab2\4ae3086df4f10891ec632eb7f1288f4.png)

#### **(二）HTTP请求报文的方法**

请求报文的第一行“请求行”只有三个内容，即**方法**，请求资源的URL，以及 HTTP协议的版本。

请求报文中常用的几种方法如下：![7936bba2b4d6471c2b6c033b60546f6](E:\computer_network\Lab2\7936bba2b4d6471c2b6c033b60546f6.png)

为了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。

- PUT：上传文件，向服务器添加数据，可以看作增
- DELETE：删除文件
- POST：传输数据，向服务器提交数据，对服务器数据进行更新。
- GET：获取资源，查询服务器资源

#### **(三）HTTP相应报文的状态码**

HTTP响应报文的状态行包括三项内容，即 HTTP的版本，**状态码**，以及解释状态码的简单短语。

下面三种状态行在响应报文中是经常见到的：

```HTTP/1.1 202 Accepted           {接受}```
```HTTP/1.1 400 Bad Request        {错误的请求}```
```Http/1.1 404 Not Found          {找不到}```

**状态码(Status-Code)**负责表示客户端 HTTP 请求的返回结果、标记服务器端 的处理是否正常、通知出现的错误等工作。状态码(Status-Code)都是三位数字的，分为5大类。这5大类的状态码都是以不同的数字开头的。

![91448e595e9b9a0a98835f6c5b384f7](E:\computer_network\Lab2\91448e595e9b9a0a98835f6c5b384f7.png)

让我们对第一轮的http请求与响应过程进行分析：

##### 1.客户端向服务器发送请求

![4cfae1f2026f4f84b61c2873a4bd41c](.\4cfae1f2026f4f84b61c2873a4bd41c.png)

- **第 1747 行**：客户端向服务器发送 `GET / HTTP/1.1` 请求。

  - **源端口**：55805
  - **目标端口**：8081
  - **标志位**：`PSH, ACK`（立即推送并等待确认）
  - **序列号**：1
  - **确认号**：1
  - **数据长度**：758 字节

  

##### 2.服务器端回复 ACK 表示收到请求

![b2ed4d4faa2498a7542fe9670de1c3c](.\b2ed4d4faa2498a7542fe9670de1c3c.png)

- **第 1748 行**：服务器端发送 `ACK` 包，以确认收到客户端的请求。

  - **源端口**：8081
  - **目标端口**：55805
  - **标志位**：`ACK`
  - **序列号**：1
  - **确认号**：759
  - **数据长度**：0（只有确认，没有数据）

  

##### 3.服务器向客户端发送响应报文

![5907ece00f5b81c45bef1c8722c3d5b](.\5907ece00f5b81c45bef1c8722c3d5b.png)

- **第 1751 行**：服务器向客户端发送 `HTTP/1.1 200 OK(text/html)` 响应报文，包含主页内容。
  - **源端口**：8081
  - **目标端口**：55805
  - **标志位**：`PSH, ACK`
  - **序列号**：1
  - **确认号**：759
  - **数据长度**：1114 字节



##### 4.客户端回复 ACK 表示收到响应

![b584189ae497604f6740776685a6e81](.\b584189ae497604f6740776685a6e81.png)

- **第 1753 行**：客户端发送 `ACK` 包，确认已成功接收到服务器的响应。
  - **源端口**：55805
  - **目标端口**：8081
  - **标志位**：`ACK`
  - **序列号**：759
  - **确认号**：1115
  - **数据长度**：0（只有确认，没有数据）

客户端的 `ACK` 包表示服务器发送的响应已经成功到达，第一轮请求和响应过程完成。



### 3. TCP四次挥手关闭连接

在所有HTTP请求完成后，客户端和服务器通过四次挥手来关闭连接，确保资源释放和连接关闭：

- 首先客户端要关闭连接,先把报文中标志位`FIN`置为1，然后向服务端发送FIN报文表示要关闭连接，之后客户端进入`FIN_WAIT`为`1`状态，但仍然可以接收数据。

- 服务端收到客户端发来的FIN报文之后,内核会自动回复一个`ACK`给客户端，之后服务端进入`CLOSED_WAIT`状态。表示接收到客户端的断开请求，但未准备好立即关闭。

- 等待服务端进程调用`close`函数，也就是等待服务端处理完数据之后，服务端在给客户端发送FIN报文表示请求断开连接，之后服务端进入`LAST_ACK`状态。

- 客户端收到服务端发来的`FIN`报文之后,会回复最后一个`ACK`报文，客户端进入`TIME_WAIT`状态，`2MSL`后,进入`closed`状态  (注意只有主动关闭连接的一方才会有`TIME_WAIT`状态)。

- 服务端接收到客户端的最后一个`ACK`报文后，就会进入`closed`状态,关闭连接。

- 如果四次挥手过程中发生报文丢失，TCP 会通过超时重传机制进行恢复。例如，如果客户端发送的 `FIN` 报文丢失，客户端将等待超时后重传，直到收到服务器的 `ACK`。同样，若服务器的 `FIN` 丢失，客户端会在 `TIME_WAIT` 状态中重新发送 `ACK`。这种机制保证了即使报文丢失，连接仍能可靠关闭。

  ![2b6a978ea53ad9acef2556199e1e9de](E:\computer_network\Lab2\2b6a978ea53ad9acef2556199e1e9de.png)

在抓包过程中，由于浏览器在请求时通常会自动设置 `Keep-Alive`，这意味着浏览器会尝试保持 TCP 连接不断开，以便复用连接传输多个请求。这种行为导致在浏览器请求中不容易捕获到四次挥手的过程。

![7717c7053b5701161b7c5921d555fac](E:\computer_network\Lab2\7717c7053b5701161b7c5921d555fac.png)

为了避免浏览器的 `Keep-Alive` 设置对实验的干扰，我通过在终端中使用 `curl` 命令（`curl http://127.0.0.1:8081`）来手动发起 HTTP 请求，这样可以强制关闭连接，确保捕获到标准的四次挥手过程。

在wireshark中可以看到四次挥手的过程：

![48e2909367e113dfa1dd3ace7b203bd](E:\computer_network\Lab2\48e2909367e113dfa1dd3ace7b203bd.png)

**1.客户端发送 `FIN, ACK`**

- **数据包 156**：客户端（端口 50559）向服务器（端口 8081）发送 `FIN, ACK` 包，请求关闭连接。
- **标志位**：`FIN, ACK`
- **序列号**：78
- **确认号**：1115

**2.服务器确认客户端的关闭请求 `ACK`**

- **数据包 157**：服务器（端口 8081）发送 `ACK` 包，确认收到客户端的关闭请求。
- **标志位**：`ACK`
- **序列号**：1115
- **确认号**：79

**3.服务器发送 `FIN, ACK`，请求关闭**

- **数据包 157**：服务器（端口 8081）向客户端发送 `FIN, ACK` 包，请求关闭连接。
- **标志位**：`FIN, ACK`
- **序列号**：1115
- **确认号**：79

**4.客户端确认服务器的关闭请求 `ACK`**

- **数据包 158**：客户端（端口 50559）发送 `ACK` 包，确认收到服务器的关闭请求。
- **标志位**：`ACK`
- **序列号**：79
- **确认号**：1116

在实际操作中，操作系统可能会优化连接关闭过程。为了提高效率，服务器可能将 `FIN` 和 `ACK` 包合并，导致在抓包中无法清晰地看到独立的第三步。即三次挥手。

## 五、问题与思考
#### 1.为什么是三次握手而不是一次或两次？

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。如果此时客户端发送的延迟的握手信息服务器收到，然后服务器进行响应，认为客户端要和它建立连接，此时客户端并没有这个意思，但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。

#### 2.为什么断开连接需要四次挥手而不是三次或两次？

TCP 协议的四次挥手是为了确保连接双方可以独立、可靠地关闭自己的发送和接收通道。每一方都需要发送一个 `FIN` 报文和一个 `ACK` 报文，以此来表明自己不再发送数据，同时确认对方的关闭请求。客户端首先发送 `FIN` 表示不再发送数据，服务器收到后回复 `ACK`，并等待所有数据处理完毕后再发送 `FIN` 请求关闭。最后，客户端发送 `ACK` 确认断开。

四次挥手避免了数据丢失风险，因为服务器不能立即发送 `FIN`，需等到所有数据发送完成后再关闭。如果减少为三次或两次挥手，可能导致数据丢失或资源浪费。因此，四次挥手设计保障了连接的可靠断开。

#### 3.为什么需要 TIME_WAIT 状态？

- 防止旧的报文进入了相同的四元组连接中
- 能够保证被动关闭方正常关闭.

#### **4.为什么四次挥手后，主动方需等待2MSL**

在TCP协议中，主动关闭连接的一方在发送最后⼀个ACK报文后，会进入一个称为`TIMEWAIT`的状态，并在这个状态中等待2个最大报文生存时间（Maximum Segment Lifetime，MSL）后才最终关闭连接。这样做主要是基于以下几个原因：

- 确保最后一个`ACK`报文的到达：等待2MSL可以确保最后⼀个`ACK`报文能够到达被动关闭方。如果最后⼀个`ACK`报文在网络中丢失，被动关闭方会重新发送`FIN`报文。在`TIME-WAIT`状态中，主动关闭方能够重新发送`ACK`报文来响应重发的`FIN`报文。 

- 避免旧数据干扰新连接：等待2MSL也可以确保该连接持续期间的所有报文都从网络中消失，防止这些旧报文在连接关闭后误导新的连接。`MSL`是网络中任何报文可能存在的最长时间，2MSL可以确保报文在两个方向上的传播都已经完全结束。

#### 5.TCP协议有什么改进空间

- **头部压缩与减少开销**：TCP 头部相对较大，尤其在小数据包（如 IoT）传输时显得浪费。使用头部压缩或简化的协议（如 QUIC）可以提高小数据包的传输效率。

- **连接建立与断开速度优化**：TCP 的三次握手和四次挥手在高频连接创建和断开时存在较大延迟。新的协议如 QUIC，通过减少握手次数和改进连接管理来提升速度，尤其适合短连接和实时应用。

---

